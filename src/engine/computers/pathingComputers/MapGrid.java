package engine.computers.pathingComputers;

import java.util.ArrayList;
import java.util.List;
import java.util.function.BiConsumer;
import javafx.geometry.Point2D;
import javafx.scene.shape.Polygon;


public class MapGrid {
    public static final int TILE_WIDTH = 96;
    public static final int TILE_HEIGHT = 48;
    private Location[][] locationGrid;

    public MapGrid (Number mapWidth, Number mapHeight) {
        System.out.println("Width: "+mapWidth+", mapHeight: "+mapHeight);
        int numRows = (int) Math.ceil(mapWidth.doubleValue() / TILE_WIDTH);
        int numColumns = (int) Math.ceil(mapHeight.doubleValue() / TILE_HEIGHT);
        locationGrid = new Location[numRows][numColumns];
        initializeGrid();
    }

    private void initializeGrid () {
        for (int i = 0; i < locationGrid.length; i++) {
            for (int j = 0; j < locationGrid[0].length; j++) {
                locationGrid[i][j] = new Location(i * TILE_WIDTH, j * TILE_HEIGHT);
            }
        }
    }

    /**
     * To be used to find neighbors from a Location that was generated by this grid - i.e. one that
     * has myX and myY as multiples of TILE_WIDTH and TILE_HEIGHT, respectively.
     * 
     * @param centerLocation
     * @return
     */
    public List<Location> getNeighbors (Location centerLocation) {
        List<Location> neighbors = new ArrayList<Location>();
        int xPosition = (int) Math.round(centerLocation.myX / TILE_WIDTH);
        int yPosition = (int) Math.round(centerLocation.myY / TILE_HEIGHT);
        int[] xDelta = { -1, -1, -1, 0, 0, 1, 1, 1 };
        int[] yDelta = { -1, 0, 1, -1, 1, -1, 0, 1 };

        for (int i = 0; i < xDelta.length; i++) {
            int newX = xPosition + xDelta[i];
            int newY = yPosition + yDelta[i];
            if ((newX < locationGrid.length && newX >= 0) &&
                (newY < locationGrid[0].length && newY >= 0)) {
                Location potentialLoc = locationGrid[newX][newY];
                if (potentialLoc != null) {
                    neighbors.add(potentialLoc);
                }
            }
        }
        return neighbors;
    }

    /**
     * To be used to find neighbors from a Location that does not exist in the grid - i.e. one that
     * lies between grid points.
     * 
     * @param x
     * @param y
     * @return
     */
    public List<Location> getNeighborsForXYCoordinate (Location XY) {
        List<Location> neighbors = new ArrayList<Location>();
        int xFloor = (int) Math.floor(XY.myX / TILE_WIDTH);
        int yFloor = (int) Math.floor(XY.myY / TILE_HEIGHT);
        int[] xDelta = { 0, 0, 1, 1 };
        int[] yDelta = { 0, 1, 0, 1 };
        for (int i = 0; i < xDelta.length; i++) {
            Location potentialLoc = locationGrid[xFloor + xDelta[i]][yFloor + yDelta[i]];
            if (potentialLoc != null) {
                neighbors.add(potentialLoc);
            }
        }
        return neighbors;
    }

    @Override
    public String toString () {
        StringBuilder array = new StringBuilder();
        for (int i = 0; i < locationGrid.length; i++) {
            for (int j = 0; j < locationGrid[0].length; j++) {
                String locationString = locationGrid[i][j] == null ? "XX" : "__";
                array.append(String.format("%1$-3s", locationString));
            }
            array.append("\n");
        }
        return array.toString();
    }

    public List<Location> getImpassableLocations () {
        List<Location> impasses = new ArrayList<Location>();
        for (int i = 0; i < locationGrid.length; i++) {
            for (int j = 0; j < locationGrid[0].length; j++) {
                if (locationGrid[i][j] == null) {
                    impasses.add(new Location(i * TILE_WIDTH, j * TILE_HEIGHT));
                }
            }
        }
        return impasses;
    }

    public void registerObstaclePlacement (double[] bounds) {
        alterLocationsInsideBounds(bounds, (x, y) -> locationGrid[x][y] = null);
    }

    public void registerObstacleRemoval (double[] bounds) {
        alterLocationsInsideBounds(bounds, (x, y) -> locationGrid[x][y] =
                new Location(x * TILE_WIDTH, y * TILE_HEIGHT));
    }

    private void alterLocationsInsideBounds (double[] bounds,
                                             BiConsumer<Integer, Integer> alteringFunction) {
        Polygon bound = new Polygon(bounds);
        Location minCorner = new Location(bounds[0], bounds[1]);
        int xIndexMinBound = (int) (Math.floor(minCorner.myX / TILE_WIDTH) - 1);
        int yIndexMinBound = (int) (Math.floor(minCorner.myY / TILE_WIDTH) - 1);
        Location maxCorner = new Location(bounds[4], bounds[5]);
        int xIndexMaxBound = (int) (Math.ceil(maxCorner.myX / TILE_WIDTH) + 1);
        int yIndexMaxBound = (int) (Math.ceil(maxCorner.myY / TILE_WIDTH) + 1);

        for (int x = xIndexMinBound; x < xIndexMaxBound; x++) {
            for (int y = yIndexMinBound; y < yIndexMaxBound; y++) {
                Location locationOfInterest = locationGrid[x][y];
                if (locationOfInterest != null) {
                    Point2D location = new Point2D(locationOfInterest.myX, locationOfInterest.myY);
                    if (bound.contains(location)) {
                        alteringFunction.accept(x, y);
                    }
                }
            }
        }
    }
}
