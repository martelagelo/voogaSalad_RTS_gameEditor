package game_engine.computers.pathingComputers;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;


public class MapGrid {
    public static final int TILE_WIDTH = 96;
    public static final int TILE_HEIGHT = 48;
    private Location[][] locationGrid;

    public MapGrid (double mapWidth, double mapLength) {
        locationGrid =
                new Location[(int) Math.ceil(mapWidth / TILE_WIDTH)][(int) Math.ceil(mapLength /
                                                                                     TILE_HEIGHT)];
        hardCodeAGrid();
    }

    private void hardCodeAGrid () {
        for (int i = 0; i < locationGrid.length; i++) {
            if (i < 8  && i > 3){
                for (int j = 0; j < locationGrid[0].length; j++) {
                    if ( j!=locationGrid[0].length-15){
                        locationGrid[i][j] = new Location(i * TILE_WIDTH, j * TILE_HEIGHT);
                    }
                }
            }
            else if (i != 8) {
                for (int j = 0; j < locationGrid[0].length; j++) {
                    locationGrid[i][j] = new Location(i * TILE_WIDTH, j * TILE_HEIGHT);
                }
            }
            else {
                for (int j = 0; j < 4; j++) {
                    locationGrid[i][j] = new Location(i * TILE_WIDTH, j * TILE_HEIGHT);
                }
                for (int j=locationGrid[0].length-1;j>locationGrid[0].length-15;j--){
                    locationGrid[i][j] = new Location(i * TILE_WIDTH, j * TILE_HEIGHT);
                }
            }
        }
    }

    /**
     * To be used to find neighbors from a Location that was generated by this grid - i.e. one that
     * has myX and myY as multiples of TILE_WIDTH and TILE_HEIGHT, respectively.
     * 
     * @param centerLocation
     * @return
     */
    public List<Location> getNeighbors (Location centerLocation) {
        List<Location> neighbors = new ArrayList<Location>();
        int xPosition = (int) Math.round(centerLocation.myX / TILE_WIDTH);
        int yPosition = (int) Math.round(centerLocation.myY / TILE_HEIGHT);
        int[] xDelta = { -1, -1, -1, 0, 0, 1, 1, 1 };
        int[] yDelta = { -1, 0, 1, -1, 1, -1, 0, 1 };

        for (int i = 0; i < xDelta.length; i++) {
            int newX = xPosition + xDelta[i];
            int newY = yPosition + yDelta[i];
            if ((newX < locationGrid.length && newX >= 0) &&
                (newY < locationGrid[0].length && newY >= 0)) {
                Location potentialLoc = locationGrid[newX][newY];
                if (potentialLoc != null) {
                    neighbors.add(potentialLoc);
                }
            }
        }
        return neighbors;
    }

    /**
     * To be used to find neighbors from a Location that does not exist in the grid - i.e. one that
     * lies between grid points.
     * 
     * @param x
     * @param y
     * @return
     */
    public List<Location> getNeighborsForXYCoordinate (Location XY) {
        List<Location> neighbors = new ArrayList<Location>();
        int xFloor = (int) Math.floor(XY.myX / TILE_WIDTH);
        int yFloor = (int) Math.floor(XY.myY / TILE_HEIGHT);
        int[] xDelta = { 0, 0, 1, 1 };
        int[] yDelta = { 0, 1, 0, 1 };
        for (int i = 0; i < xDelta.length; i++) {
            Location potentialLoc = locationGrid[xFloor + xDelta[i]][yFloor + yDelta[i]];
            if (potentialLoc != null) {
                neighbors.add(potentialLoc);
            }
        }
        return neighbors;
    }

    @Override
    public String toString () {
        StringBuilder array = new StringBuilder();
        for (int i = 0; i < locationGrid.length; i++) {
            for (int j = 0; j < locationGrid[0].length; j++) {
                String locationString = locationGrid[i][j] == null ? "XX" : "__"; 
                array.append(String.format("%1$-3s", locationString));
            }
            array.append("\n");
        }
        return array.toString();
    }
    
    public List<Location> getImpassableLocations(){
        List<Location> impasses = new ArrayList<Location>();
        for (int i = 0; i < locationGrid.length; i++) {
            for (int j = 0; j < locationGrid[0].length; j++) {
                if(locationGrid[i][j] == null){
                    impasses.add(new Location(i * TILE_WIDTH, j * TILE_HEIGHT));
                }
            }
        }
        return impasses;
    }
}
