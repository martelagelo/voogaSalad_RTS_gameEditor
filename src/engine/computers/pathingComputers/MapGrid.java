package engine.computers.pathingComputers;

import java.util.ArrayList;
import java.util.List;
import java.util.function.BiConsumer;
import javafx.geometry.Point2D;
import javafx.scene.shape.Polygon;

public class MapGrid {
	public static final int TILE_WIDTH = 96;
	public static final int TILE_HEIGHT = 48;
	private Location[][] myLocationGrid;

	public MapGrid(Number mapWidth, Number mapHeight) {
		int numRows = (int) Math.ceil(mapWidth.doubleValue() / TILE_WIDTH);
		int numColumns = (int) Math.ceil(mapHeight.doubleValue() / TILE_HEIGHT);
		myLocationGrid = new Location[numRows][numColumns];
		initializeGrid();
	}

	private void initializeGrid() {
		for (int i = 0; i < myLocationGrid.length; i++) {
			for (int j = 0; j < myLocationGrid[0].length; j++) {
				myLocationGrid[i][j] = new Location(i * TILE_WIDTH, j * TILE_HEIGHT);
			}
		}
	}

	/**
	 * To be used to find neighbors from a Location that was generated by this
	 * grid - i.e. one that has myX and myY as multiples of TILE_WIDTH and
	 * TILE_HEIGHT, respectively.
	 * 
	 * @param centerLocation
	 * @return
	 */
	public List<Location> getNeighbors(Location centerLocation) {
		List<Location> neighbors = new ArrayList<Location>();
		int xPosition = (int) Math.round(centerLocation.getX() / TILE_WIDTH);
		int yPosition = (int) Math.round(centerLocation.getY() / TILE_HEIGHT);
		int[] xDelta = { -1, -1, -1, 0, 0, 1, 1, 1 };
		int[] yDelta = { -1, 0, 1, -1, 1, -1, 0, 1 };

		for (int i = 0; i < xDelta.length; i++) {
			int newX = xPosition + xDelta[i];
			int newY = yPosition + yDelta[i];
			if ((newX < myLocationGrid.length && newX >= 0) && (newY < myLocationGrid[0].length && newY >= 0)) {
				Location potentialLoc = myLocationGrid[newX][newY];
				if (potentialLoc != null) {
					neighbors.add(potentialLoc);
				}
			}
		}
		return neighbors;
	}

	/**
	 * To be used to find neighbors from a Location that does not exist in the
	 * grid - i.e. one that lies between grid points.
	 * 
	 * @param x
	 * @param y
	 * @return
	 */
	public List<Location> getNeighborsForXYCoordinate(Location XY) {
		List<Location> neighbors = new ArrayList<Location>();
		int xFloor = (int) Math.floor(XY.getX() / TILE_WIDTH);
		int yFloor = (int) Math.floor(XY.getY() / TILE_HEIGHT);
		int[] xDelta = { 0, 0, 1, 1 };
		int[] yDelta = { 0, 1, 0, 1 };
		for (int i = 0; i < xDelta.length; i++) {
			Location potentialLoc = myLocationGrid[xFloor + xDelta[i]][yFloor + yDelta[i]];
			if (potentialLoc != null) {
				neighbors.add(potentialLoc);
			}
		}
		return neighbors;
	}

	@Override
	public String toString() {
		StringBuilder array = new StringBuilder();
		for (int i = 0; i < myLocationGrid.length; i++) {
			for (int j = 0; j < myLocationGrid[0].length; j++) {
				String locationString = myLocationGrid[i][j] == null ? "XX" : "__";
				array.append(String.format("%1$-3s", locationString));
			}
			array.append("\n");
		}
		return array.toString();
	}

	public List<Location> getImpassableLocations() {
		List<Location> impasses = new ArrayList<Location>();
		for (int i = 0; i < myLocationGrid.length; i++) {
			for (int j = 0; j < myLocationGrid[0].length; j++) {
				if (myLocationGrid[i][j] == null) {
					impasses.add(new Location(i * TILE_WIDTH, j * TILE_HEIGHT));
				}
			}
		}
		return impasses;
	}

	public void registerObstaclePlacement(double[] bounds) {
		alterLocationsInsideBounds(bounds, (x, y) -> myLocationGrid[x][y] = null);
	}

	public void registerObstacleRemoval(double[] bounds) {
		alterLocationsInsideBounds(bounds, (x, y) -> myLocationGrid[x][y] = new Location(x * TILE_WIDTH, y
				* TILE_HEIGHT));
	}

	private void alterLocationsInsideBounds(double[] bounds, BiConsumer<Integer, Integer> alteringFunction) {
		Polygon bound = new Polygon(bounds);
		Location minCorner = new Location(bounds[0], bounds[1]);
		int xIndexMinBound = (int) (Math.floor(minCorner.getX() / TILE_WIDTH) - 1);
		int yIndexMinBound = (int) (Math.floor(minCorner.getY() / TILE_WIDTH) - 1);
		Location maxCorner = new Location(bounds[4], bounds[5]);
		int xIndexMaxBound = (int) (Math.ceil(maxCorner.getX() / TILE_WIDTH) + 1);
		int yIndexMaxBound = (int) (Math.ceil(maxCorner.getY() / TILE_WIDTH) + 1);

		for (int x = xIndexMinBound; x < xIndexMaxBound; x++) {
			for (int y = yIndexMinBound; y < yIndexMaxBound; y++) {
				Location locationOfInterest = myLocationGrid[x][y];
				if (locationOfInterest != null) {
					Point2D location = new Point2D(locationOfInterest.getX(), locationOfInterest.getY());
					if (bound.contains(location)) {
						alteringFunction.accept(x, y);
					}
				}
			}
		}
	}
}
